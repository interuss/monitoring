import os
from dataclasses import dataclass
from typing import Iterator, Sequence, List

import marko
import marko.element
from marko.ext.gfm import gfm
from marko.md_renderer import MarkdownRenderer

from monitoring.monitorlib.versioning import get_code_version, repo_url_of
from monitoring.uss_qualifier.common_data_definitions import Severity
from monitoring.uss_qualifier.configurations.configuration import (
    GloballyExpandedReportConfiguration,
)
from monitoring.uss_qualifier.documentation import text_of
from monitoring.uss_qualifier.reports.report import TestRunReport
from monitoring.uss_qualifier.reports.sequence_view.generate import (
    compute_action_node,
    make_resources_config,
)
from monitoring.uss_qualifier.reports.sequence_view.summary_types import (
    Indexer,
    ActionNode,
    ActionNodeType,
    TestedScenario,
    EpochType,
    TestedCase,
    TestedStep,
    EventType,
)
from monitoring.uss_qualifier.reports.tested_requirements.summaries import (
    compute_test_run_information,
)
from monitoring.uss_qualifier.scenarios.documentation.parsing import (
    get_documentation_by_name,
)


@dataclass
class _Section:
    title: str
    body: str


def generate_globally_expanded_report(
    report: TestRunReport, config: GloballyExpandedReportConfiguration, output_path: str
) -> None:
    node = compute_action_node(report.report, Indexer())
    test_run = compute_test_run_information(report)

    sections = list(_generate_sections(node))

    ger = (
        (
            (
                f"""# Test run {test_run.test_run_id[0:7]}

## Table of contents

### Setup

2. Test run information
3. Resource pool

### Test scenarios
"""
            )
            + "\n".join(
                f"{str(s)}. {section.title}"
                for s, section in enumerate(sections, start=4)
            )
        )
        + "\n\n"
    )

    ger += f"""## Test run information

<table>
  <tr>
    <th>Test characteristic</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>Test run identifier</td>
    <td>TR-{ test_run.test_run_id[0:7] }</td>
  </tr>
  <tr>
    <td>Start time</td>
    <td>{ test_run.start_time if test_run.start_time else "" }</td>
  </tr>
  <tr>
    <td>End time</td>
    <td>{ test_run.end_time if test_run.end_time else "" }</td>
  </tr>
  <tr>
    <td>Test baseline identifier</td>
    <td>TB-{ test_run.baseline[0:7] }</td>
  </tr>
  <tr>
    <td>Environment identifier</td>
    <td>TE-{ test_run.environment[0:7] }</td>
  </tr>
  <tr>
    <td>Codebase version</td>
    <td>{ report.codebase_version }</td>
  </tr>
  <tr>
    <td>Commit hash</td>
    <td>{ report.commit_hash }</td>
  </tr>
</table>

_This artifact was generated by { get_code_version() }_

"""

    resource_pool = make_resources_config(report.configuration.v1.test_run)

    def indented_ul(value) -> List[str]:
        result = []
        if isinstance(value, dict):
            for k, v in value.items():
                vlines = indented_ul(v)
                if len(vlines) == 1 and (not vlines[0] or vlines[0].strip()[0] != "*"):
                    vstr = vlines[0] if vlines[0] else '""'
                    result.append(f"* {k}: {vstr}")
                else:
                    result.append(f"* {k}")
                    result.extend(f"    {l}" for l in vlines)
        elif isinstance(value, str):
            result.append(value)
        elif isinstance(value, list):
            if len(value) == 0:
                result.append("[]")
            elif len(value) == 1:
                vlines = indented_ul(value[0])
                if len(vlines) == 1 and vlines[0] != "*":
                    result.append(f"[ {vlines[0]} ]")
                else:
                    result.append("* Item 1:")
                    result.extend(f"    {l}" for l in vlines)
            else:
                for i, v in enumerate(value):
                    vlines = indented_ul(v)
                    result.append(f"* Item {i + 1}:")
                    result.extend(f"    {l}" for l in vlines)
        else:
            result.append(str(value))
        return result

    def describe_pool_resource(k: str, v: dict) -> str:
        return f"#### {k}\n\n" + "\n".join(indented_ul(v))

    ger += "## Resource pool"

    if "Environment" in resource_pool and resource_pool["Environment"]:
        ger += f"\n\n### Environment\n\n" + "\n".join(
            describe_pool_resource(k, v)
            for k, v in resource_pool["Environment"].items()
        )

    if "Baseline" in resource_pool and resource_pool["Baseline"]:
        ger += f"\n\n### Baseline\n\n" + "\n".join(
            describe_pool_resource(k, v) for k, v in resource_pool["Baseline"].items()
        )

    ger += "\n\n"

    ger += "\n\n".join(f"## {section.title}\n\n{section.body}" for section in sections)

    gerdoc = gfm.parse(ger)
    _add_section_numbers(gerdoc.children[1:])

    os.makedirs(output_path, exist_ok=True)
    with open(os.path.join(output_path, "report.html"), "w") as f:
        f.write("<html>\n")
        with open(
            os.path.join(
                os.path.dirname(__file__), "../templates/globally_expanded/style.html"
            ),
            "r",
        ) as style:
            f.write(style.read())
        f.write("<body>\n")
        f.write(gfm.render(gerdoc))
        f.write("</body>\n")
        f.write("</html>\n")


def _generate_sections(node: ActionNode) -> Iterator[_Section]:
    if node.node_type == ActionNodeType.Scenario:
        yield _generate_scenario_section(node.scenario)
    elif node.node_type == ActionNodeType.SkippedAction:
        yield _generate_skipped_scenario_section(node)
    else:
        for child in node.children:
            for subsection in _generate_sections(child):
                yield subsection


def _generate_skipped_scenario_section(node: ActionNode) -> _Section:
    return _Section(
        title=f"[skipped] {node.name}",
        body=f"This instance of this test scenario was skipped in this test run because: {node.skipped_action.reason}",
    )


def _generate_scenario_section(scenario: TestedScenario) -> _Section:
    doc_summary = get_documentation_by_name(scenario.type)
    with open(doc_summary.local_path, "r") as f:
        doc = marko.parse(f.read())

    _modify_scenario_documentation(
        doc, os.path.abspath(doc_summary.local_path), scenario
    )

    renderer = MarkdownRenderer()
    return _Section(
        title=f"[S{scenario.scenario_index}] {scenario.name}",
        body=renderer.render_children(doc),
    )


def _modify_scenario_documentation(
    doc: marko.block.Document, origin_filename: str, scenario: TestedScenario
) -> None:
    _remove_top_heading(doc)
    _indent_headings(doc.children, 1)
    _inflate_fragments(doc, origin_filename)
    _add_resource_origins(doc, scenario)
    _add_context_to_scenario(doc, scenario)
    _update_links(doc, origin_filename)


def _remove_top_heading(doc: marko.block.Document) -> None:
    for c in range(len(doc.children)):
        if isinstance(doc.children[c], marko.block.Heading):
            doc.children = doc.children[c + 1 :]
            return


def _indent_headings(elements: Sequence[marko.element.Element], levels: int) -> None:
    for element in elements:
        if isinstance(element, marko.block.Heading):
            element.level = min(element.level + levels, 6)
        if hasattr(element, "children") and element.children:
            _indent_headings(element.children, levels)


def _inflate_fragments(parent: marko.element.Element, origin_filename: str) -> None:
    if hasattr(parent, "children") and parent.children:
        c = 0
        while c < len(parent.children):
            child = parent.children[c]
            if (
                isinstance(child, marko.block.Heading)
                and hasattr(child, "children")
                and len(child.children) > 0
                and isinstance(child.children[0], marko.block.inline.Link)
            ):
                # This is a heading with a link in it, so we infer this is a linked test step fragment
                doc_filename = child.children[0].dest
                absolute_path = os.path.abspath(
                    os.path.join(os.path.dirname(origin_filename), doc_filename)
                )
                doc = _get_test_step_fragment(absolute_path, child.level)
                _update_links(doc, absolute_path)
                _strip_link(child)
                parent.children = (
                    parent.children[0 : c + 1] + doc.children + parent.children[c + 1 :]
                )
                c += len(doc.children)
            elif isinstance(child, marko.element.Element):
                _inflate_fragments(parent.children[c], origin_filename)
                c += 1
            else:
                c += 1


def _add_resource_origins(doc: marko.block.Document, scenario: TestedScenario) -> None:
    resource_heading_level = None
    current_resource = None
    current_resource_i0 = None
    c = 0

    def add_resource_origin():
        nonlocal c, current_resource, current_resource_i0
        if current_resource is None:
            return
        if current_resource not in scenario.resource_origins:
            # This resource wasn't provided for this scenario instance
            note = marko.parse(
                """&empty; _This resource was not applicable to this test run and was therefore not provided._\n\n"""
            )
            doc.children = doc.children[0:c] + note.children + doc.children[c:]
            c += len(note.children)
            return
        # Insert resource origin information
        origin = marko.parse(
            f"\n\n&#x2705; Provided by {scenario.resource_origins[current_resource]}.\n"
        )
        doc.children = doc.children[0:c] + origin.children + doc.children[c:]
        c += len(origin.children)

    while c < len(doc.children):
        child = doc.children[c]
        if isinstance(child, marko.block.Heading) and text_of(child) == "Resources":
            # We just found the resources section
            resource_heading_level = child.level
            c += 1
        elif resource_heading_level is None:
            # We're not yet in the resources section
            c += 1
        elif (
            resource_heading_level is not None
            and isinstance(child, marko.block.Heading)
            and child.level <= resource_heading_level
        ):
            # This is the heading ending the resources section, so we're done
            break
        elif (
            isinstance(child, marko.block.Heading)
            and child.level == resource_heading_level + 1
        ):
            # This is the heading defining a resource
            add_resource_origin()
            current_resource = text_of(child)
            current_resource_i0 = c
            c += 1
        else:
            c += 1
    add_resource_origin()


def _strip_link(element: marko.element.Element) -> None:
    if hasattr(element, "children") and element.children:
        for c in range(len(element.children)):
            child = element.children[c]
            if isinstance(child, marko.block.inline.Link):
                element.children[c] = child.children[0]
            elif isinstance(child, marko.element.Element):
                _strip_link(child)


def _get_test_step_fragment(
    absolute_path: str, parent_level: int
) -> marko.block.Document:
    with open(absolute_path, "r") as f:
        doc = marko.parse(f.read())

    _remove_top_heading(doc)
    _indent_headings(doc.children, parent_level - 1)
    _inflate_fragments(doc, absolute_path)

    return doc


def _add_context_to_scenario(
    doc: marko.block.Document, scenario: TestedScenario
) -> None:
    test_case = None
    test_case_i0 = None
    test_case_level = None
    cleanup = False
    c = 0

    def add_context_to_case():
        nonlocal c, cleanup, test_case, test_case_i0, test_case_level
        if test_case_i0 is not None:
            if test_case is not None:
                if cleanup:
                    c += _add_context_to_step(doc, test_case.steps[0], test_case_i0, c)
                else:
                    c += _add_context_to_case(doc, test_case, test_case_i0, c)
            else:
                # This test case wasn't executed this test run
                note = marko.parse(
                    """&empty; _This test case was not applicable to this test run and is therefore not statused._\n\n"""
                )
                doc.children = (
                    doc.children[0 : test_case_i0 + 1]
                    + note.children
                    + doc.children[test_case_i0 + 1 :]
                )
                c += len(note.children)
        test_case = None
        test_case_i0 = None
        test_case_level = None
        cleanup = False

    while c < len(doc.children):
        child = doc.children[c]
        if isinstance(child, marko.block.Heading) and text_of(child).endswith(
            " test case"
        ):
            # This is the beginning of a test case
            add_context_to_case()

            case_name = text_of(child)[: -len(" test case")]
            test_case_i0 = c
            test_case_level = child.level
            for epoch in scenario.epochs:
                if epoch.type != EpochType.Case:
                    continue
                if case_name == epoch.case.name:
                    test_case = epoch.case
                    break
        elif isinstance(child, marko.block.Heading) and text_of(child) == "Cleanup":
            # This is the beginning of the cleanup section
            add_context_to_case()

            test_case_i0 = c
            test_case_level = child.level
            cleanup = True
            for epoch in scenario.epochs:
                if epoch.type != EpochType.Case:
                    continue
                if len(epoch.case.steps) == 1 and epoch.case.steps[0].name == "Cleanup":
                    test_case = epoch.case
                    break
        elif (
            test_case_level is not None
            and isinstance(child, marko.block.Heading)
            and child.level <= test_case_level
        ):
            # This heading ends the current test case section
            add_context_to_case()
        c += 1
    add_context_to_case()


def _add_context_to_case(
    doc: marko.block.Document, case: TestedCase, i0: int, i1: int
) -> int:
    test_step = None
    test_step_i0 = None
    test_step_level = None
    c = i0
    added = 0

    def add_context_to_step():
        nonlocal c, i1, added, test_step, test_step_i0, test_step_level
        if test_step_i0 is not None:
            if test_step is not None:
                dc = _add_context_to_step(doc, test_step, test_step_i0, c)
            else:
                # This test step wasn't executed this test run
                note = marko.parse(
                    """&empty; _This test step was not applicable to this test run and is therefore not statused._\n\n"""
                )
                dc = len(note.children)
                doc.children = (
                    doc.children[0 : test_step_i0 + 1]
                    + note.children
                    + doc.children[test_step_i0 + 1 :]
                )
            c += dc
            i1 += dc
            added += dc
        test_step = None
        test_step_i0 = None
        test_step_level = None

    while c < i1:
        child = doc.children[c]
        if isinstance(child, marko.block.Heading) and text_of(child).endswith(
            " test step"
        ):
            # This is the beginning of a test step
            add_context_to_step()

            step_name = text_of(child)[: -len(" test step")]
            test_step_i0 = c
            test_step_level = child.level
            for step in case.steps:
                if step_name == step.name:
                    test_step = step
                    break
        elif (
            test_step_level is not None
            and isinstance(child, marko.block.Heading)
            and child.level <= test_step_level
        ):
            # This heading ends the current test case section
            add_context_to_step()
        c += 1
    add_context_to_step()
    return added


def _add_context_to_step(
    doc: marko.block.Document, step: TestedStep, i0: int, i1: int
) -> int:
    test_check_name = None
    test_check_i0 = None
    test_check_level = None
    c = i0
    added = 0

    def add_context_to_check():
        nonlocal c, i1, added, test_check_name, test_check_i0, test_check_level
        if test_check_name is not None:
            dc = _add_context_to_check(doc, step, test_check_name, test_check_i0, c)
            c += dc
            i1 += dc
            added += dc
        test_check_name = None
        test_check_i0 = None
        test_check_level = None

    while c < i1:
        child = doc.children[c]
        if isinstance(child, marko.block.Heading) and text_of(child).endswith(" check"):
            # This is the beginning of a test check
            add_context_to_check()

            test_check_name = text_of(child)[: -len(" check")]
            for sev in Severity.all_values():
                prefix = sev.symbol + " "
                if test_check_name.startswith(prefix):
                    test_check_name = test_check_name[len(prefix) :]
            test_check_i0 = c
            test_check_level = child.level
        elif (
            test_check_level is not None
            and isinstance(child, marko.block.Heading)
            and child.level <= test_check_level
        ):
            # This heading ends the current test check section
            add_context_to_check()
        c += 1
    add_context_to_check()
    return added


def _add_context_to_check(
    doc: marko.block.Document, step: TestedStep, test_check_name: str, i0: int, i1: int
) -> int:
    check_text = [""]
    for event in step.events:
        if (
            event.type == EventType.PassedCheck
            and event.passed_check.name == test_check_name
        ):
            check_text.append(
                f"&#x2705; {', '.join(event.passed_check.participants)} ({event.passed_check.timestamp})"
            )
        elif (
            event.type == EventType.FailedCheck
            and event.failed_check.name == test_check_name
        ):
            check_text.append(
                f"&#x274C; {', '.join(event.failed_check.participants)} ({event.failed_check.timestamp})"
            )
    if len(check_text) > 1:
        additions = marko.parse("\n\n".join(check_text))
    else:
        additions = marko.parse(
            """&empty; _This check was not applicable to this test run and is therefore not statused._\n\n"""
        )
    doc.children = doc.children[0:i1] + additions.children + doc.children[i1:]
    return len(additions.children)


def _update_links(element: marko.element.Element, origin_filename: str) -> None:
    if isinstance(element, marko.block.inline.Link) or isinstance(
        element, marko.block.inline.Image
    ):
        if not element.dest.startswith("http://") and not element.dest.startswith(
            "https://"
        ):
            absolute_path = os.path.realpath(
                os.path.join(os.path.dirname(origin_filename), element.dest)
            )
            url = repo_url_of(absolute_path)
            if isinstance(element, marko.block.inline.Image):
                url = url.replace("/github.com/", "/raw.githubusercontent.com/")
                url = url.replace("/blob/", "/")
            element.dest = url
    if hasattr(element, "children") and element.children:
        for child in element.children:
            if isinstance(child, marko.element.Element):
                _update_links(child, origin_filename)


def _add_section_numbers(elements: Sequence[marko.element.Element]) -> None:
    heading_level = 2
    levels = [0]
    headings = [None]
    prev_heading = None
    for i, element in enumerate(elements):
        if isinstance(element, marko.block.Heading):
            if element.level < heading_level:
                levels = levels[0 : element.level - heading_level]
                headings = headings[0 : element.level - heading_level]
                heading_level = element.level
                levels[-1] += 1
                headings[-1] = text_of(element)
            elif element.level == heading_level:
                levels[-1] += 1
                headings[-1] = text_of(element)
            elif element.level == heading_level + 1:
                levels.append(1)
                headings.append(text_of(element))
                heading_level += 1
            else:
                headings.append(text_of(element))
                heading_trace = " -> ".join(headings)
                raise ValueError(
                    f"Encountered a level {element.level} heading ({text_of(element)}) at element {i} following a level {heading_level} heading ({prev_heading}); expected heading levels to increase by 1 level at a time.  Trace: {heading_trace}"
                )
            prev_heading = text_of(element)
            section_number = ".".join(str(level) for level in levels) + ". "
            if isinstance(element.children[0], marko.block.inline.RawText):
                element.children[0].children = (
                    section_number + element.children[0].children
                )
            else:
                element.children = [
                    marko.block.inline.RawText(section_number)
                ] + element.children
